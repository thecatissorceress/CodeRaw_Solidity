
// SPDX-License-Identifier: SEE LICENSE IN LICENSE
pragma solidity ^0.8.7;
/* 
ERC1155
- Is ownable
- Each token ID needs to have a max supply of 1
- Token IDs will be 0, 1, 2, 3 but users can see 1, 2, 3 
- Each token should have its own baseURI, meaning I can have two NFTs with different baseURI
- URL for each token should be changeable by contract owner
- A new token can be minted by contract owner with input parameters: string uri
- Token ID is autogenerated and incremental
- Tokens should be minted to fixed address 'treasury'
- 'treasury' should be updatable by owner
*/

import "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

contract ERC1155Token is Ownable, ERC1155 {
    uint public maxSupply = 1;
    uint public token_Id = 0;
    address public treasury;

    mapping(uint => string)public baseURI;

    
    constructor (address _treasury) ERC1155(""){
        treasury = _treasury;
    }

    function mint(string memory _baseURI) public onlyOwner{
        _mint( treasury, token_Id,maxSupply,"A NFT");
        baseURI[token_Id] = _baseURI;
        token_Id++;
    }

    function uri(uint tokenId)public view override returns(string memory){
        require(tokenId <= token_Id);
        return string(abi.encodePacked(baseURI[tokenId - 1],'/',Strings.toString(tokenId),'.json'));
    }

    function changeBaseURI(uint tokenCount, string memory newUri) public onlyOwner{
            baseURI[tokenCount -1] = newUri; 
    }



    function updateTreasury (address _treasury) public onlyOwner {
        treasury = _treasury;
    }
}